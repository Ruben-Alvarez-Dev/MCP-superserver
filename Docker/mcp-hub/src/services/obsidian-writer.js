// ============================================================
// Obsidian Backend Integration
// ============================================================
// Task: US-004 - Write logs to Obsidian markdown files
// Description: Markdown file operations for Obsidian vault

import fs from 'fs/promises';
import path from 'path';
import { logger } from '../utils/logger.js';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Obsidian configuration
 */
const obsidianConfig = {
  vaultPath: process.env.OBSIDIAN_VAULT_PATH || '/app/obsidian-vault',
  logsFolder: process.env.OBSIDIAN_LOGS_FOLDER || 'MCP Logs',
  dateFormat: 'yyyy-MM-dd',
  encoding: 'utf-8'
};

/**
 * Ensure vault directory exists
 */
async function ensureVaultDirectory() {
  const logsPath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder);

  try {
    await fs.mkdir(logsPath, { recursive: true });
    logger.debug('Obsidian vault directory ensured', { path: logsPath });
  } catch (error) {
    logger.error('Failed to create Obsidian vault directory', {
      error: error.message,
      path: logsPath
    });
    throw error;
  }
}

/**
 * Format date for filename
 */
function formatDateForFilename(date = new Date()) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Format ISO 8601 timestamp
 */
function formatTimestamp(date = new Date()) {
  return date.toISOString();
}

/**
 * Create YAML frontmatter
 */
function createFrontmatter(metadata) {
  const lines = ['---'];

  for (const [key, value] of Object.entries(metadata)) {
    if (Array.isArray(value)) {
      lines.push(`${key}:`);
      for (const item of value) {
        lines.push(`  - ${item}`);
      }
    } else if (typeof value === 'object') {
      lines.push(`${key}:`);
      for (const [subKey, subValue] of Object.entries(value)) {
        lines.push(`  ${subKey}: ${subValue}`);
      }
    } else {
      lines.push(`${key}: ${value}`);
    }
  }

  lines.push('---');
  return lines.join('\n');
}

/**
 * Write log entry to Obsidian markdown file
 */
export async function writeLogEntry(logEntry) {
  const { timestamp, type, source, action, data, tags } = logEntry;

  try {
    await ensureVaultDirectory();

    const filename = `${formatDateForFilename(new Date(timestamp))}.md`;
    const filepath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder, filename);

    // Create frontmatter
    const frontmatter = createFrontmatter({
      title: `${type} - ${action}`,
      date: formatTimestamp(new Date(timestamp)),
      type,
      source,
      action,
      tags: tags || ['mcp-log', type, source]
    });

    // Create content
    const content = `${frontmatter}

## Overview

**Type**: ${type}
**Source**: ${source}
**Action**: ${action}
**Timestamp**: ${formatTimestamp(new Date(timestamp))}

## Details

${formatDataAsMarkdown(data)}

---

*Generated by MCP-SUPERSERVER Hub*
`;

    // Append to file
    await fs.appendFile(filepath, `${content}\n\n`, {
      encoding: obsidianConfig.encoding,
      flag: 'a'
    });

    logger.info('Log entry written to Obsidian', {
      filename,
      type,
      source,
      action
    });

    return { success: true, filepath };
  } catch (error) {
    logger.error('Failed to write log entry to Obsidian', {
      error: error.message,
      logEntry
    });
    throw error;
  }
}

/**
 * Format data as markdown
 */
function formatDataAsMarkdown(data, indent = 0) {
  const prefix = '  '.repeat(indent);

  if (!data || typeof data !== 'object') {
    return `${prefix}${String(data)}`;
  }

  if (Array.isArray(data)) {
    if (data.length === 0) {
      return `${prefix}*Empty array*`;
    }
    return data.map(item => `${prefix}- ${formatDataAsMarkdown(item, 0)}`).join('\n');
  }

  const lines = [];
  for (const [key, value] of Object.entries(data)) {
    if (typeof value === 'object' && value !== null) {
      lines.push(`${prefix}**${key}**:`);
      lines.push(formatDataAsMarkdown(value, indent + 1));
    } else {
      lines.push(`${prefix}**${key}**: ${value}`);
    }
  }

  return lines.join('\n');
}

/**
 * Write MCP tool call to Obsidian
 */
export async function writeMcpToolCall(toolName, server, args, result, duration) {
  return writeLogEntry({
    timestamp: new Date().toISOString(),
    type: 'tool_call',
    source: server,
    action: toolName,
    data: {
      arguments: args,
      result: result,
      duration_ms: duration
    },
    tags: ['mcp', 'tool-call', server, toolName]
  });
}

/**
 * Write AI reasoning trace to Obsidian
 */
export async function writeReasoningTrace(source, prompt, reasoning, conclusion) {
  return writeLogEntry({
    timestamp: new Date().toISOString(),
    type: 'reasoning',
    source,
    action: 'thinking',
    data: {
      prompt,
      reasoning,
      conclusion
    },
    tags: ['mcp', 'reasoning', source]
  });
}

/**
 * Write memory operation to Obsidian
 */
export async function writeMemoryOperation(operation, entity, result) {
  return writeLogEntry({
    timestamp: new Date().toISOString(),
    type: 'memory',
    source: 'neo4j',
    action: operation,
    data: {
      entity,
      result
    },
    tags: ['mcp', 'memory', operation]
  });
}

/**
 * Write system event to Obsidian
 */
export async function writeSystemEvent(event, details) {
  return writeLogEntry({
    timestamp: new Date().toISOString(),
    type: 'system',
    source: 'hub',
    action: event,
    data: details,
    tags: ['mcp', 'system', event]
  });
}

/**
 * Write error to Obsidian
 */
export async function writeError(error, context) {
  return writeLogEntry({
    timestamp: new Date().toISOString(),
    type: 'error',
    source: context.source || 'unknown',
    action: 'error',
    data: {
      message: error.message,
      stack: error.stack,
      context
    },
    tags: ['mcp', 'error', context.source || 'unknown']
  });
}

/**
 * Get all log files
 */
export async function getLogFiles() {
  try {
    await ensureVaultDirectory();
    const logsPath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder);

    const files = await fs.readdir(logsPath);
    const mdFiles = files.filter(f => f.endsWith('.md'));

    return mdFiles.sort().reverse();
  } catch (error) {
    logger.error('Failed to read log files', { error: error.message });
    throw error;
  }
}

/**
 * Read log file content
 */
export async function readLogFile(filename) {
  try {
    const filepath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder, filename);
    const content = await fs.readFile(filepath, { encoding: obsidianConfig.encoding });
    return content;
  } catch (error) {
    logger.error('Failed to read log file', { error: error.message, filename });
    throw error;
  }
}

/**
 * Delete old log files (retention policy)
 */
export async function cleanupOldLogs(daysToKeep = 30) {
  try {
    const files = await getLogFiles();
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    let deletedCount = 0;

    for (const file of files) {
      const fileDate = new Date(file.replace('.md', ''));
      if (fileDate < cutoffDate) {
        const filepath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder, file);
        await fs.unlink(filepath);
        deletedCount++;
      }
    }

    if (deletedCount > 0) {
      logger.info('Cleaned up old log files', { deletedCount, daysToKeep });
    }

    return deletedCount;
  } catch (error) {
    logger.error('Failed to cleanup old logs', { error: error.message });
    throw error;
  }
}

/**
 * Write custom markdown content
 */
export async function writeMarkdown(filename, content, frontmatter = {}) {
  try {
    await ensureVaultDirectory();

    const filepath = path.join(obsidianConfig.vaultPath, obsidianConfig.logsFolder, filename);

    const fullContent = Object.keys(frontmatter).length > 0
      ? `${createFrontmatter(frontmatter)}\n\n${content}`
      : content;

    await fs.writeFile(filepath, fullContent, {
      encoding: obsidianConfig.encoding,
      flag: 'w'
    });

    logger.info('Markdown file written', { filename });
    return { success: true, filepath };
  } catch (error) {
    logger.error('Failed to write markdown file', { error: error.message, filename });
    throw error;
  }
}

export default {
  writeLogEntry,
  writeMcpToolCall,
  writeReasoningTrace,
  writeMemoryOperation,
  writeSystemEvent,
  writeError,
  getLogFiles,
  readLogFile,
  cleanupOldLogs,
  writeMarkdown,
  obsidianConfig
};
